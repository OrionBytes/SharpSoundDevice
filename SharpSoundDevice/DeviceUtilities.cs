using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace SharpSoundDevice
{
	/// <summary>
	/// Class containing various helper methods.
	/// </summary>
	public class DeviceUtilities
	{
		/// <summary>
		/// Generates a 4-byte integer by hashing an input string and taking modulus.
		/// Useful to create VST Id that is unique to your plugin
		/// </summary>
		/// <param name="seedString">input string, e.g. plugin and developer name</param>
		/// <returns></returns>
		public static int GenerateIntegerId(string seedString)
		{
			var bytes = Encoding.UTF8.GetBytes(seedString);
			SHA256Managed hashstring = new SHA256Managed();
			byte[] hash = hashstring.ComputeHash(bytes);
			var bignum = BitConverter.ToUInt64(hash, 4);
			return (Int32)(bignum % Int32.MaxValue);
		}

		/// <summary>
		/// Accepts an array of Parameters and returns their values in a serialized format.
		/// </summary>
		/// <param name="parameters"></param>
		/// <returns></returns>
		public static byte[] SerializeParameters(Parameter[] parameters)
		{
			parameters = parameters.OrderBy(x => x.Index).ToArray();

			string output = "";
			foreach (var p in parameters)
				output += p.Value.ToString(System.Globalization.CultureInfo.InvariantCulture) + ", ";

			return Encoding.UTF8.GetBytes(output);
		}

		/// <summary>
		/// Takes output generated by SerializeParameters(), deserializes it and assigns the values
		/// to the Parameters
		/// </summary>
		/// <param name="parameters">An array of parameters to set with the new values</param>
		/// <param name="data">Serialized values, as generated by the SerializeParameters() method</param>
		public static void DeserializeParameters(Parameter[] parameters, byte[] data)
		{
			parameters = parameters.OrderBy(x => x.Index).ToArray();

			string values = Encoding.UTF8.GetString(data);
			var items = values.Split(',');
			var filtered = items.Where(x => x != null && x.Trim() != "").ToList();
			var select = filtered.Select(x => Convert.ToDouble(x.Trim(), System.Globalization.CultureInfo.InvariantCulture)).ToList();

			if (select.Count != parameters.Length)
				throw new Exception("Illegal program data. Number of parameters does not match");

			for (int i = 0; i < parameters.Length; i++)
				parameters[i].Value = select[i];
		}

		/// <summary>
		/// Copies data from double** into managed 2d array
		/// </summary>
		/// <param name="ptr"></param>
		/// <param name="InputPortCount"></param>
		/// <param name="bufferSize"></param>
		/// <returns></returns>
		public static double[][] GetManagedSamples(IntPtr ptr, int InputPortCount, uint bufferSize)
		{
			unsafe
			{
				double** input = (double**)ptr;

				var output = new double[InputPortCount][];
				for (int i = 0; i < InputPortCount; i++)
				{
					double[] ch = new double[bufferSize];
					output[i] = ch;

					Marshal.Copy((IntPtr)input[i], ch, 0, (int)bufferSize);
				}

				return output;
			}
		}

		/// <summary>
		/// Creates an empty 2d managed array
		/// </summary>
		/// <param name="InputPortCount"></param>
		/// <param name="bufferSize"></param>
		/// <returns></returns>
		public static double[][] GetEmptyArrays(int InputPortCount, uint bufferSize)
		{
			var output = new double[InputPortCount][];

			for (int i = 0; i < InputPortCount; i++)
				output[i] = new double[bufferSize];

			return output;
		}

		/// <summary>
		/// Copies data from a managed 2d array into an unmanaged double**
		/// </summary>
		/// <param name="outp"></param>
		/// <param name="ptr"></param>
		/// <param name="OutputPortCount"></param>
		/// <param name="bufferSize"></param>
		public static void CopyToUnmanaged(double[][] outp, IntPtr ptr, int OutputPortCount, uint bufferSize)
		{
			unsafe
			{
				double** output = (double**)ptr;

				for (int i = 0; i < OutputPortCount; i++)
				{
					void* channel = output[i];
					Marshal.Copy(outp[i], 0, (IntPtr)channel, (int)bufferSize);
				}
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="input"></param>
		/// <param name="buffer"></param>
		/// <param name="maxLen"></param>
		public static void CopyStringToBuffer(string input, IntPtr buffer, int maxLen)
		{
			var bytes = Encoding.UTF8.GetBytes(input + '\0');
			int count = (maxLen < bytes.Length) ? maxLen : bytes.Length;
			Marshal.Copy(bytes, 0, buffer, count);

			// add null terminator at end of buffer
			unsafe
			{
				byte* ptr = (byte*)buffer;
				ptr[maxLen - 1] = 0;
			}
		}

#if Windows

		[System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
		static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);

		/// <summary>
		/// Helper method used to dock a Wpf window inside a Vst Window.
		/// All UI chrome is hidden away (borders, close/minimize/maximize buttons)
		/// and the window becomes embedded inside the parent window
		/// </summary>
		/// <param name="WpfWindow"></param>
		/// <param name="vstWindow"></param>
		public static void DockWpfWindow(System.Windows.Window WpfWindow, IntPtr vstWindow)
		{
			WpfWindow.Top = 0;
			WpfWindow.Left = 0;
			WpfWindow.ShowInTaskbar = false;
			WpfWindow.WindowStyle = System.Windows.WindowStyle.None;
			WpfWindow.ResizeMode = System.Windows.ResizeMode.NoResize;
			WpfWindow.Show();
			var windowHwnd = new System.Windows.Interop.WindowInteropHelper(WpfWindow);
			IntPtr hWnd = windowHwnd.Handle;
			SetParent(hWnd, vstWindow);
		}

		/// <summary>
		/// Docks a Winforms panel inside the parent window.
		/// </summary>
		/// <param name="panel"></param>
		/// <param name="vstWindow"></param>
		public static void DockWinFormsPanel(System.Windows.Forms.Control panel, IntPtr vstWindow)
		{
			System.Windows.Forms.Application.EnableVisualStyles();

			panel.Top = 0;
			panel.Left = 0;

			SetParent(panel.Handle, vstWindow);
		}
#endif

	}
}
